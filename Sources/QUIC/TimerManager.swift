/// Timer Manager
///
/// Manages timers for QUIC connections including:
/// - ACK delay timers
/// - PTO (Probe Timeout) timers
/// - Idle timeout timers
/// - Loss detection timers

import Foundation
import Synchronization
import QUICCore

// MARK: - Timer Event

/// Events generated by timer expiry
public enum TimerEvent: Sendable {
    /// ACK timer expired, should send ACK
    case sendAck(ManagedConnection)

    /// PTO expired, should send probe
    case probe(ManagedConnection)

    /// Idle timeout expired, close connection
    case idleTimeout(ManagedConnection)

    /// Loss timer expired, check for lost packets
    case lossDetection(ManagedConnection)
}

// MARK: - Timer Manager

/// Manages timers for all connections
///
/// Provides a unified timer management system that:
/// - Tracks the next deadline for each connection
/// - Returns the earliest deadline across all connections
/// - Generates appropriate events when timers expire
public final class TimerManager: Sendable {
    // MARK: - Properties

    /// Registered connections and their timer info
    private let connections: Mutex<[ConnectionID: TimerInfo]>

    /// Idle timeout duration (configurable)
    private let idleTimeout: Duration

    // MARK: - Types

    /// Timer information for a connection
    private struct TimerInfo: Sendable {
        /// The connection
        let connection: ManagedConnection

        /// Last activity time
        var lastActivity: ContinuousClock.Instant

        /// Whether connection is closed
        var isClosed: Bool = false
    }

    // MARK: - Initialization

    /// Creates a timer manager
    /// - Parameter idleTimeout: Idle timeout duration (default 30 seconds)
    public init(idleTimeout: Duration = .seconds(30)) {
        self.connections = Mutex([:])
        self.idleTimeout = idleTimeout
    }

    // MARK: - Registration

    /// Registers a connection for timer management
    /// - Parameter connection: The connection to register
    public func register(_ connection: ManagedConnection) {
        let info = TimerInfo(
            connection: connection,
            lastActivity: .now
        )
        connections.withLock { $0[connection.sourceConnectionID] = info }
    }

    /// Unregisters a connection
    /// - Parameter connection: The connection to unregister
    public func unregister(_ connection: ManagedConnection) {
        _ = connections.withLock { $0.removeValue(forKey: connection.sourceConnectionID) }
    }

    /// Updates the last activity time for a connection
    /// - Parameter connection: The connection that had activity
    public func recordActivity(for connection: ManagedConnection) {
        connections.withLock { conns in
            if var info = conns[connection.sourceConnectionID] {
                info.lastActivity = .now
                conns[connection.sourceConnectionID] = info
            }
        }
    }

    /// Marks a connection as closed
    /// - Parameter connection: The connection that closed
    public func markClosed(_ connection: ManagedConnection) {
        connections.withLock { conns in
            if var info = conns[connection.sourceConnectionID] {
                info.isClosed = true
                conns[connection.sourceConnectionID] = info
            }
        }
    }

    // MARK: - Timer Processing

    /// Gets the next timer deadline across all connections
    /// - Returns: The earliest deadline, or nil if no timers pending
    public func nextDeadline() -> ContinuousClock.Instant? {
        return connections.withLock { conns in
            var earliest: ContinuousClock.Instant? = nil

            for (_, info) in conns {
                guard !info.isClosed else { continue }

                // Get connection's next timer deadline
                if let connectionDeadline = info.connection.nextTimerDeadline() {
                    if earliest == nil || connectionDeadline < earliest! {
                        earliest = connectionDeadline
                    }
                }

                // Check idle timeout
                let idleDeadline = info.lastActivity + idleTimeout
                if earliest == nil || idleDeadline < earliest! {
                    earliest = idleDeadline
                }
            }

            return earliest
        }
    }

    /// Processes expired timers and returns events
    /// - Parameter now: Current time
    /// - Returns: Array of timer events
    public func processTimers(now: ContinuousClock.Instant = .now) -> [TimerEvent] {
        var events: [TimerEvent] = []

        connections.withLock { conns in
            for (cid, info) in conns {
                guard !info.isClosed else { continue }

                // Check idle timeout
                let idleDeadline = info.lastActivity + idleTimeout
                if idleDeadline <= now {
                    events.append(.idleTimeout(info.connection))
                    // Mark as closed
                    var updatedInfo = info
                    updatedInfo.isClosed = true
                    conns[cid] = updatedInfo
                    continue
                }

                // Check connection's timer
                if let connectionDeadline = info.connection.nextTimerDeadline(),
                   connectionDeadline <= now {
                    // Determine event type based on connection state
                    if info.connection.isEstablished {
                        events.append(.lossDetection(info.connection))
                    } else {
                        events.append(.probe(info.connection))
                    }
                }
            }
        }

        return events
    }

    /// Waits for the next timer to expire
    /// - Returns: Timer events when they occur
    public func waitForNextTimer() async -> [TimerEvent] {
        guard let deadline = nextDeadline() else {
            // No timers pending, wait indefinitely (or could return empty)
            try? await Task.sleep(for: .seconds(1))
            return []
        }

        let now = ContinuousClock.Instant.now
        if deadline <= now {
            // Already expired
            return processTimers(now: now)
        }

        // Wait until deadline
        let waitDuration = deadline - now
        try? await Task.sleep(for: waitDuration)

        return processTimers()
    }

    // MARK: - Statistics

    /// Number of registered connections
    public var connectionCount: Int {
        connections.withLock { $0.count }
    }

    /// Number of active (non-closed) connections
    public var activeConnectionCount: Int {
        connections.withLock { conns in
            // Use reduce to count in single pass without intermediate array allocation
            conns.values.reduce(0) { count, info in
                info.isClosed ? count : count + 1
            }
        }
    }
}

// MARK: - Timer Wheel (Optimized for many connections)

/// A timer wheel for efficient timer management with many connections
///
/// Uses a hierarchical wheel structure for O(1) timer insertion and
/// O(n) worst case expiry processing where n is the number of expiring timers.
public final class TimerWheel: Sendable {
    // MARK: - Properties

    /// Wheel slots (each slot contains connections expiring in that time range)
    private let slots: Mutex<[[ConnectionID: ManagedConnection]]>

    /// Wheel size (number of slots)
    private let wheelSize: Int

    /// Tick duration (time per slot)
    private let tickDuration: Duration

    /// Current tick
    private let currentTick: Mutex<Int>

    // MARK: - Initialization

    /// Creates a timer wheel
    /// - Parameters:
    ///   - wheelSize: Number of slots (default 256)
    ///   - tickDuration: Duration per tick (default 100ms)
    public init(wheelSize: Int = 256, tickDuration: Duration = .milliseconds(100)) {
        self.wheelSize = wheelSize
        self.tickDuration = tickDuration
        self.slots = Mutex(Array(repeating: [:], count: wheelSize))
        self.currentTick = Mutex(0)
    }

    /// Adds a timer for a connection
    /// - Parameters:
    ///   - connection: The connection
    ///   - delay: Delay until the timer fires
    public func addTimer(for connection: ManagedConnection, delay: Duration) {
        let ticks = Int(delay.components.seconds * 1000 + delay.components.attoseconds / 1_000_000_000_000_000) / Int(tickDuration.components.seconds * 1000 + tickDuration.components.attoseconds / 1_000_000_000_000_000)

        let currentTickValue = currentTick.withLock { $0 }
        let targetSlot = (currentTickValue + max(1, ticks)) % wheelSize

        slots.withLock { slots in
            slots[targetSlot][connection.sourceConnectionID] = connection
        }
    }

    /// Advances the wheel by one tick
    /// - Returns: Connections whose timers expired
    public func tick() -> [ManagedConnection] {
        let tickValue = currentTick.withLock { tick in
            let current = tick
            tick = (tick + 1) % wheelSize
            return current
        }

        return slots.withLock { slots in
            let expired = Array(slots[tickValue].values)
            slots[tickValue].removeAll()
            return expired
        }
    }

    /// Removes a connection's timer
    /// - Parameter connection: The connection to remove
    public func removeTimer(for connection: ManagedConnection) {
        slots.withLock { slots in
            for i in 0..<wheelSize {
                slots[i].removeValue(forKey: connection.sourceConnectionID)
            }
        }
    }
}
