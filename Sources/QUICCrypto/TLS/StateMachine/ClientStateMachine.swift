/// TLS 1.3 Client State Machine
///
/// Implements the client-side TLS 1.3 handshake for QUIC.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
import Crypto
import Synchronization
import QUICCore

// MARK: - Client State Machine

/// Client-side TLS 1.3 state machine
package final class ClientStateMachine: Sendable {

    private let state = Mutex<ClientState>(ClientState())

    private struct ClientState: Sendable {
        var handshakeState: ClientHandshakeState = .start
        var context: HandshakeContext = HandshakeContext()
        var configuration: TLSConfiguration = TLSConfiguration()
    }

    // MARK: - Initialization

    package init() {}

    // MARK: - Start Handshake

    /// Generate ClientHello and start the handshake
    /// - Parameters:
    ///   - configuration: TLS configuration
    ///   - transportParameters: QUIC transport parameters to send
    ///   - sessionTicket: Optional session ticket for resumption
    ///   - attemptEarlyData: Whether to attempt 0-RTT early data
    /// - Returns: The ClientHello message and any TLS outputs
    package func startHandshake(
        configuration: TLSConfiguration,
        transportParameters: Data,
        sessionTicket: SessionTicketData? = nil,
        attemptEarlyData: Bool = false
    ) throws -> (clientHello: Data, outputs: [TLSOutput]) {
        return try state.withLock { state in
            guard state.handshakeState == .start else {
                throw TLSHandshakeError.unexpectedMessage("Handshake already started")
            }

            state.configuration = configuration
            state.context.localTransportParameters = transportParameters
            state.context.sessionTicket = sessionTicket

            // Generate ephemeral key for key exchange (prefer X25519)
            let keyExchange = try KeyExchange.generate(for: .x25519)
            state.context.keyExchange = keyExchange

            // Generate random
            let key = SymmetricKey(size: .bits256)
            let random = key.withUnsafeBytes { Data($0) }

            state.context.clientRandom = random

            // Session ID for TLS 1.3 over QUIC
            // RFC 9001 Section 8.4: "For middlebox compatibility, QUIC implementations
            // SHOULD send a legacy_session_id field in ClientHello that contains a
            // 32-byte value generated by the client."
            // However, quictls (used by ngtcp2) requires an empty session ID for QUIC-TLS.
            // Using empty session ID for broader interoperability.
            let sessionID = Data()
            state.context.sessionID = sessionID

            // Build extensions
            var extensions: [TLSExtension] = []

            // supported_versions (required for TLS 1.3)
            extensions.append(.supportedVersionsClient([TLSConstants.version13]))

            // supported_groups
            extensions.append(.supportedGroupsList([.x25519, .secp256r1]))

            // signature_algorithms - comprehensive list for wide compatibility
            extensions.append(.signatureAlgorithmsList([
                .ecdsa_secp256r1_sha256,
                .ecdsa_secp384r1_sha384,
                .rsa_pss_rsae_sha256,
                .rsa_pss_rsae_sha384,
                .rsa_pss_rsae_sha512,
                .ed25519
            ]))

            // key_share
            extensions.append(.keyShareClient([keyExchange.keyShareEntry()]))

            // ALPN
            if !configuration.alpnProtocols.isEmpty {
                extensions.append(.alpnProtocols(configuration.alpnProtocols))
            }

            // Server name (SNI)
            if let serverName = configuration.serverName {
                extensions.append(.serverName(ServerNameExtension(hostName: serverName)))
            }

            // QUIC transport parameters
            extensions.append(.quicTransportParameters(transportParameters))

            // Build the cipher suites list
            var cipherSuites: [CipherSuite] = [.tls_aes_128_gcm_sha256]

            // PSK-related extensions (if we have a session ticket)
            var pskExtensionsInfo: (offered: OfferedPsks, ticket: SessionTicketData)?

            if let ticket = sessionTicket, ticket.isValid() {
                // If resuming, prefer the original cipher suite
                cipherSuites = [ticket.cipherSuite, .tls_aes_128_gcm_sha256]

                // psk_key_exchange_modes (required when offering PSKs)
                // QUIC requires psk_dhe_ke mode
                extensions.append(.pskKeyExchangeModesList([.psk_dhe_ke]))

                // early_data (if attempting 0-RTT)
                // Sanity check: limit max early data to 16MB to prevent memory issues
                // from maliciously large values
                let maxAllowedEarlyData: UInt32 = 16 * 1024 * 1024  // 16 MB
                let effectiveMaxEarlyData = min(ticket.maxEarlyDataSize, maxAllowedEarlyData)

                if attemptEarlyData && effectiveMaxEarlyData > 0 {
                    extensions.append(.earlyDataClient())
                    state.context.earlyDataState.attemptingEarlyData = true
                    state.context.earlyDataState.maxEarlyDataSize = effectiveMaxEarlyData
                }

                // pre_shared_key must be the last extension
                // Create the PSK identity from the ticket
                let pskIdentity = PskIdentity(ticket: ticket)
                let offeredPsks = OfferedPsks(
                    identities: [pskIdentity],
                    binders: [Data(repeating: 0, count: ticket.cipherSuite.hashLength)] // Placeholder
                )
                pskExtensionsInfo = (offered: offeredPsks, ticket: ticket)

                // Initialize key schedule with PSK
                let psk = SymmetricKey(data: ticket.resumptionPSK)
                state.context.keySchedule = TLSKeySchedule(cipherSuite: ticket.cipherSuite)
                state.context.keySchedule.deriveEarlySecret(psk: psk)

                // Store the PSK cipher suite for 0-RTT key output
                // (will be updated to negotiated suite after ServerHello)
                state.context.cipherSuite = ticket.cipherSuite
            }

            // If offering PSK, we need to compute binders using a two-pass approach
            var clientHelloMessage: Data
            if let pskInfo = pskExtensionsInfo {
                let ticket = pskInfo.ticket
                var offeredPsks = pskInfo.offered

                // First pass: Build ClientHello with placeholder binders
                var extensionsWithPsk = extensions
                extensionsWithPsk.append(.preSharedKeyClient(offeredPsks))

                let placeholderClientHello = ClientHello(
                    random: random,
                    legacySessionID: sessionID,
                    cipherSuites: cipherSuites,
                    extensions: extensionsWithPsk
                )

                // Encode ClientHello to get the transcript up to binders
                let clientHelloWithPlaceholder = placeholderClientHello.encodeAsHandshake()

                // Compute the truncated transcript (excluding binders)
                let bindersSectionSize = offeredPsks.bindersSize
                let truncatedClientHello = clientHelloWithPlaceholder.prefix(clientHelloWithPlaceholder.count - bindersSectionSize)

                // Initialize transcript hash with truncated ClientHello
                var transcriptHashForBinder = TranscriptHash(cipherSuite: ticket.cipherSuite)
                transcriptHashForBinder.update(with: Data(truncatedClientHello))

                // Compute binder
                let binderKey = try state.context.keySchedule.deriveBinderKey(isResumption: true)
                state.context.binderKey = binderKey
                let transcriptHash = transcriptHashForBinder.currentHash()
                let finishedKeyForBinder = state.context.keySchedule.finishedKey(from: binderKey)
                let binder = state.context.keySchedule.finishedVerifyData(
                    forKey: finishedKeyForBinder,
                    transcriptHash: transcriptHash
                )

                // Second pass: Rebuild ClientHello with correct binders
                offeredPsks.binders = [binder]

                var finalExtensions = extensions
                finalExtensions.append(.preSharedKeyClient(offeredPsks))

                let finalClientHello = ClientHello(
                    random: random,
                    legacySessionID: sessionID,
                    cipherSuites: cipherSuites,
                    extensions: finalExtensions
                )

                clientHelloMessage = finalClientHello.encodeAsHandshake()

                // Derive early traffic secret if attempting 0-RTT
                if state.context.earlyDataState.attemptingEarlyData {
                    var earlyTranscript = TranscriptHash(cipherSuite: ticket.cipherSuite)
                    earlyTranscript.update(with: clientHelloMessage)
                    let earlySecret = try state.context.keySchedule.deriveClientEarlyTrafficSecret(
                        transcriptHash: earlyTranscript.currentHash()
                    )
                    state.context.clientEarlyTrafficSecret = earlySecret
                }
            } else {
                // Standard ClientHello without PSK
                let clientHello = ClientHello(
                    random: random,
                    legacySessionID: sessionID,
                    cipherSuites: cipherSuites,
                    extensions: extensions
                )
                clientHelloMessage = clientHello.encodeAsHandshake()
            }

            // Update transcript
            state.context.transcriptHash.update(with: clientHelloMessage)

            // Transition state
            state.handshakeState = .waitServerHello

            // Prepare outputs
            var outputs: [TLSOutput] = []

            // If attempting early data, provide the early keys (0-RTT)
            if let earlySecret = state.context.clientEarlyTrafficSecret,
               let cipherSuite = state.context.cipherSuite {
                outputs.append(.keysAvailable(KeysAvailableInfo(
                    level: .zeroRTT,
                    clientSecret: earlySecret,
                    serverSecret: earlySecret, // Not used for 0-RTT (client-to-server only)
                    cipherSuite: cipherSuite.toQUICCipherSuite
                )))
            }

            return (clientHelloMessage, outputs)
        }
    }

    // MARK: - Process ServerHello

    /// Process a ServerHello message
    /// - Parameter data: The ServerHello message content (without handshake header)
    /// - Returns: TLS outputs (keys available, etc.)
    package func processServerHello(_ data: Data) throws -> [TLSOutput] {
        return try state.withLock { state in
            // Accept ServerHello in waitServerHello or waitServerHelloRetry states
            guard state.handshakeState == .waitServerHello ||
                  state.handshakeState == .waitServerHelloRetry else {
                throw TLSHandshakeError.unexpectedMessage("Unexpected ServerHello in state \(state.handshakeState)")
            }

            let serverHello = try ServerHello.decode(from: data)

            // Check for HelloRetryRequest
            if serverHello.isHelloRetryRequest {
                return try processHelloRetryRequest(serverHello, data: data, state: &state)
            }

            // Verify supported_versions extension
            guard let supportedVersions = serverHello.supportedVersions,
                  supportedVersions.isTLS13 else {
                throw TLSHandshakeError.unsupportedVersion
            }

            // Validate legacy_session_id_echo (must match what we sent)
            guard serverHello.legacySessionIDEcho == state.context.sessionID else {
                throw TLSHandshakeError.invalidExtension("ServerHello legacy_session_id_echo does not match ClientHello")
            }

            // Validate cipher suite (must be one we offered)
            let offeredCipherSuites: [CipherSuite] = [.tls_aes_128_gcm_sha256, .tls_aes_256_gcm_sha384]
            guard offeredCipherSuites.contains(serverHello.cipherSuite) else {
                throw TLSHandshakeError.noCipherSuiteMatch
            }

            // Check for PSK acceptance
            var pskAccepted = false
            if let pskExtension = serverHello.extensions.first(where: { $0.extensionType == .preSharedKey }) {
                if case .preSharedKey(.serverHello(let selectedPsk)) = pskExtension {
                    // Verify the selected identity is valid (we only offer 1 PSK, so must be 0)
                    guard selectedPsk.selectedIdentity == 0 else {
                        throw TLSHandshakeError.invalidExtension("Invalid PSK selection: \(selectedPsk.selectedIdentity)")
                    }

                    // RFC 8446 Section 4.2.11: The cipher suite MUST match the PSK's cipher suite
                    // state.context.cipherSuite was set to ticket.cipherSuite when we started with PSK
                    if let pskCipherSuite = state.context.cipherSuite,
                       pskCipherSuite != serverHello.cipherSuite {
                        throw TLSHandshakeError.invalidExtension(
                            "Cipher suite mismatch: PSK uses \(pskCipherSuite), server selected \(serverHello.cipherSuite)"
                        )
                    }

                    pskAccepted = true
                    state.context.pskUsed = true
                    state.context.selectedPskIdentity = selectedPsk.selectedIdentity
                }
            }

            // Get key_share extension (required even for PSK-DHE mode)
            guard let serverKeyShare = serverHello.keyShare else {
                throw TLSHandshakeError.missingExtension("key_share")
            }

            // Verify we have a key for this group
            guard let ourKeyExchange = state.context.keyExchange,
                  ourKeyExchange.group == serverKeyShare.serverShare.group else {
                throw TLSHandshakeError.noKeyShareMatch
            }

            // Perform key agreement
            let sharedSecret = try ourKeyExchange.sharedSecret(with: serverKeyShare.serverShare.keyExchange)
            state.context.sharedSecret = sharedSecret

            // Store cipher suite
            state.context.cipherSuite = serverHello.cipherSuite
            state.context.serverRandom = serverHello.random

            // Update transcript with ServerHello
            let serverHelloMessage = HandshakeCodec.encode(type: .serverHello, content: data)
            state.context.transcriptHash.update(with: serverHelloMessage)

            // Initialize or update key schedule for the selected cipher suite
            if !pskAccepted {
                // Non-PSK mode: reinitialize key schedule with no PSK
                state.context.keySchedule = TLSKeySchedule(cipherSuite: serverHello.cipherSuite)
                state.context.keySchedule.deriveEarlySecret(psk: nil)
            }
            // If PSK was accepted, early secret was already derived with PSK in startHandshake

            // Derive handshake secrets
            let transcriptHash = state.context.transcriptHash.currentHash()
            let (clientSecret, serverSecret) = try state.context.keySchedule.deriveHandshakeSecrets(
                sharedSecret: sharedSecret,
                transcriptHash: transcriptHash
            )

            state.context.clientHandshakeSecret = clientSecret
            state.context.serverHandshakeSecret = serverSecret

            // Transition state
            state.handshakeState = .waitEncryptedExtensions

            // Return keys available output
            return [
                .keysAvailable(KeysAvailableInfo(
                    level: .handshake,
                    clientSecret: clientSecret,
                    serverSecret: serverSecret
                ))
            ]
        }
    }

    // MARK: - Process HelloRetryRequest

    /// Process a HelloRetryRequest message
    /// - Parameters:
    ///   - hrr: The decoded HelloRetryRequest (ServerHello with special random)
    ///   - data: The raw message data
    ///   - state: The client state (mutable)
    /// - Returns: TLS outputs including the new ClientHello2
    private func processHelloRetryRequest(
        _ hrr: ServerHello,
        data: Data,
        state: inout ClientState
    ) throws -> [TLSOutput] {
        // Ensure we haven't already received an HRR (only one allowed)
        guard !state.context.receivedHelloRetryRequest else {
            throw TLSHandshakeError.unexpectedMessage("Received second HelloRetryRequest")
        }
        state.context.receivedHelloRetryRequest = true

        // Get the requested group from HRR
        guard let requestedGroup = hrr.helloRetryRequestSelectedGroup else {
            throw TLSHandshakeError.missingExtension("key_share in HelloRetryRequest")
        }

        // Verify we support the requested group
        let supportedGroups: [NamedGroup] = [.x25519, .secp256r1]
        guard supportedGroups.contains(requestedGroup) else {
            throw TLSHandshakeError.noKeyShareMatch
        }

        // Store cipher suite from HRR
        state.context.cipherSuite = hrr.cipherSuite

        // RFC 8446 Section 4.4.1: Special transcript handling for HRR
        // Save the hash of ClientHello1
        let clientHello1Hash = state.context.transcriptHash.currentHash()
        state.context.originalClientHello1Hash = clientHello1Hash

        // Replace transcript with message_hash synthetic message
        state.context.transcriptHash = TranscriptHash.fromMessageHash(
            clientHello1Hash: clientHello1Hash,
            cipherSuite: hrr.cipherSuite
        )

        // Add HRR to transcript
        let hrrMessage = HandshakeCodec.encode(type: .serverHello, content: data)
        state.context.transcriptHash.update(with: hrrMessage)

        // Generate new key pair for the requested group
        let newKeyExchange = try KeyExchange.generate(for: requestedGroup)
        state.context.keyExchange = newKeyExchange

        // Build ClientHello2 with the new key share
        let clientHello2 = try generateClientHello2(state: &state, keyExchange: newKeyExchange)

        // Transition state
        state.handshakeState = .waitServerHelloRetry

        // Return the new ClientHello
        return [.handshakeData(clientHello2, level: .initial)]
    }

    /// Generate ClientHello2 after HelloRetryRequest
    private func generateClientHello2(
        state: inout ClientState,
        keyExchange: KeyExchange
    ) throws -> Data {
        // Build extensions (similar to startHandshake but with new key_share)
        var extensions: [TLSExtension] = []

        // supported_versions (required for TLS 1.3)
        extensions.append(.supportedVersionsClient([TLSConstants.version13]))

        // supported_groups
        extensions.append(.supportedGroupsList([.x25519, .secp256r1]))

        // signature_algorithms - comprehensive list for wide compatibility
        extensions.append(.signatureAlgorithmsList([
            .ecdsa_secp256r1_sha256,
            .ecdsa_secp384r1_sha384,
            .rsa_pss_rsae_sha256,
            .rsa_pss_rsae_sha384,
            .rsa_pss_rsae_sha512,
            .ed25519
        ]))

        // key_share with the new key
        extensions.append(.keyShareClient([keyExchange.keyShareEntry()]))

        // ALPN
        if !state.configuration.alpnProtocols.isEmpty {
            extensions.append(.alpnProtocols(state.configuration.alpnProtocols))
        }

        // Server name (SNI)
        if let serverName = state.configuration.serverName {
            extensions.append(.serverName(ServerNameExtension(hostName: serverName)))
        }

        // QUIC transport parameters
        if let params = state.context.localTransportParameters {
            extensions.append(.quicTransportParameters(params))
        }

        // Build ClientHello2
        guard let clientRandom = state.context.clientRandom,
              let sessionID = state.context.sessionID else {
            throw TLSHandshakeError.internalError("Missing client random or session ID")
        }

        let clientHello = ClientHello(
            random: clientRandom,
            legacySessionID: sessionID,
            cipherSuites: [.tls_aes_128_gcm_sha256, .tls_aes_256_gcm_sha384],
            extensions: extensions
        )

        // Encode and update transcript
        let clientHelloMessage = clientHello.encodeAsHandshake()
        state.context.transcriptHash.update(with: clientHelloMessage)

        return clientHelloMessage
    }

    // MARK: - Process EncryptedExtensions

    /// Process an EncryptedExtensions message
    /// - Parameter data: The EncryptedExtensions message content
    /// - Returns: TLS outputs
    package func processEncryptedExtensions(_ data: Data) throws -> [TLSOutput] {
        return try state.withLock { state in
            guard state.handshakeState == .waitEncryptedExtensions else {
                throw TLSHandshakeError.unexpectedMessage("Unexpected EncryptedExtensions")
            }

            let encryptedExtensions = try EncryptedExtensions.decode(from: data)

            // Extract ALPN (required for QUIC per RFC 9001)
            guard let alpn = encryptedExtensions.selectedALPN else {
                throw TLSHandshakeError.noALPNMatch
            }
            // Verify server's ALPN is one we offered
            guard state.configuration.alpnProtocols.contains(alpn) else {
                throw TLSHandshakeError.noALPNMatch
            }
            state.context.negotiatedALPN = alpn

            // Extract QUIC transport parameters (required for QUIC)
            guard let params = encryptedExtensions.quicTransportParameters else {
                throw TLSHandshakeError.missingExtension("quic_transport_parameters")
            }
            state.context.peerTransportParameters = params

            // Check for early_data acceptance
            let earlyDataAccepted = encryptedExtensions.extensions.contains {
                $0.extensionType == .earlyData
            }

            if state.context.earlyDataState.attemptingEarlyData {
                state.context.earlyDataState.earlyDataAccepted = earlyDataAccepted
                // If early data was not accepted, client must discard any sent 0-RTT data
                // and retransmit in 1-RTT (handled at QUIC layer)
            }

            // Update transcript
            let message = HandshakeCodec.encode(type: .encryptedExtensions, content: data)
            state.context.transcriptHash.update(with: message)

            // Transition state - skip Certificate/CertificateVerify if PSK was used
            if state.context.pskUsed {
                state.handshakeState = .waitFinished
            } else {
                // Server may send CertificateRequest before Certificate (for mTLS)
                state.handshakeState = .waitCertificateOrCertificateRequest
            }

            return []
        }
    }

    // MARK: - Process CertificateRequest

    /// Process a CertificateRequest message (for mutual TLS)
    ///
    /// RFC 8446 Section 4.3.2: Server requests client authentication.
    /// Client stores the context and will send Certificate + CertificateVerify after receiving Finished.
    /// - Parameter data: The CertificateRequest message content
    /// - Returns: TLS outputs
    package func processCertificateRequest(_ data: Data) throws -> [TLSOutput] {
        return try state.withLock { state in
            // CertificateRequest comes after EncryptedExtensions, before server's Certificate
            guard state.handshakeState == .waitCertificateOrCertificateRequest else {
                throw TLSHandshakeError.unexpectedMessage("Unexpected CertificateRequest in state \(state.handshakeState)")
            }

            let certRequest = try CertificateRequest.decode(from: data)

            // Store context to echo back in client's Certificate message
            state.context.certificateRequestContext = certRequest.certificateRequestContext
            state.context.clientCertificateRequested = true

            // Update transcript
            let message = HandshakeCodec.encode(type: .certificateRequest, content: data)
            state.context.transcriptHash.update(with: message)

            // Continue to wait for server's Certificate
            state.handshakeState = .waitCertificate

            return []
        }
    }

    // MARK: - Process Certificate

    /// Process a Certificate message
    /// - Parameter data: The Certificate message content
    /// - Returns: TLS outputs
    package func processCertificate(_ data: Data) throws -> [TLSOutput] {
        return try state.withLock { state in
            // Accept Certificate from either waiting state
            guard state.handshakeState == .waitCertificate ||
                  state.handshakeState == .waitCertificateOrCertificateRequest else {
                throw TLSHandshakeError.unexpectedMessage("Unexpected Certificate")
            }

            let certificate = try Certificate.decode(from: data)

            // Store raw certificates
            state.context.peerCertificates = certificate.certificates

            // Parse and validate X.509 certificate if verification is enabled
            // Skip X.509 parsing if expectedPeerPublicKey is set (raw public key verification)
            if state.configuration.verifyPeer && state.configuration.expectedPeerPublicKey == nil {
                guard let leafCertData = certificate.leafCertificate else {
                    throw TLSHandshakeError.certificateVerificationFailed("No certificate provided")
                }

                // Parse the leaf certificate
                let leafCert: X509Certificate
                do {
                    leafCert = try X509Certificate.parse(from: leafCertData)
                } catch {
                    throw TLSHandshakeError.certificateVerificationFailed("Failed to parse certificate: \(error)")
                }

                // Store the parsed certificate
                state.context.peerCertificate = leafCert

                // Parse intermediate certificates
                let intermediateCerts = try certificate.certificates.dropFirst().compactMap { certData -> X509Certificate? in
                    try X509Certificate.parse(from: certData)
                }

                // Set up validation options
                var validationOptions = X509ValidationOptions()
                validationOptions.hostname = state.configuration.serverName
                validationOptions.allowSelfSigned = state.configuration.allowSelfSigned
                // RFC 5280 Section 4.2.1.12: Server certificates MUST have serverAuth EKU
                validationOptions.requiredEKU = .serverAuth

                // Create validator with effective trusted roots.
                // effectiveTrustedRoots resolves trustedRootCertificates first,
                // then falls back to parsing trustedCACertificates (DER) if set.
                let validator = X509Validator(
                    trustedRoots: state.configuration.effectiveTrustedRoots,
                    options: validationOptions
                )

                // Validate the certificate chain and store the validated chain
                // for subsequent revocation checking (Phase B integration).
                do {
                    let validatedChain = try validator.buildValidatedChain(
                        certificate: leafCert,
                        intermediates: Array(intermediateCerts)
                    )
                    // Store chain for async revocation check in TLS13Handler
                    state.context.validatedChain = validatedChain
                } catch let error as X509Error {
                    throw TLSHandshakeError.certificateVerificationFailed(error.description)
                }

                // Extract and store the public key for CertificateVerify verification
                do {
                    state.context.peerVerificationKey = try leafCert.extractPublicKey()
                } catch {
                    throw TLSHandshakeError.certificateVerificationFailed("Failed to extract public key: \(error)")
                }
            }

            // Update transcript
            let message = HandshakeCodec.encode(type: .certificate, content: data)
            state.context.transcriptHash.update(with: message)

            // Transition state
            state.handshakeState = .waitCertificateVerify

            return []
        }
    }

    // MARK: - Process CertificateVerify

    /// Process a CertificateVerify message
    /// - Parameter data: The CertificateVerify message content
    /// - Returns: TLS outputs
    package func processCertificateVerify(_ data: Data) throws -> [TLSOutput] {
        return try state.withLock { state in
            guard state.handshakeState == .waitCertificateVerify else {
                throw TLSHandshakeError.unexpectedMessage("Unexpected CertificateVerify")
            }

            let certificateVerify = try CertificateVerify.decode(from: data)

            // Get the transcript hash up to (but not including) CertificateVerify
            let transcriptHash = state.context.transcriptHash.currentHash()

            // Construct the content that was signed
            let signedContent = TLSSignature.certificateVerifyContent(
                transcriptHash: transcriptHash,
                isServer: true
            )

            // Determine which verification key to use
            let verificationKey: VerificationKey?

            if let expectedPublicKey = state.configuration.expectedPeerPublicKey {
                // Use explicitly configured public key
                verificationKey = try VerificationKey(
                    publicKeyBytes: expectedPublicKey,
                    scheme: certificateVerify.algorithm
                )
            } else if let extractedKey = state.context.peerVerificationKey {
                // Use public key extracted from certificate
                verificationKey = extractedKey
            } else {
                verificationKey = nil
            }

            // Verify signature if we have a verification key
            if let key = verificationKey {
                // Verify the signature scheme matches the key type
                guard key.scheme == certificateVerify.algorithm else {
                    throw TLSHandshakeError.signatureVerificationFailed
                }

                // Verify the signature
                let isValid = try key.verify(
                    signature: certificateVerify.signature,
                    for: signedContent
                )

                guard isValid else {
                    throw TLSHandshakeError.signatureVerificationFailed
                }
            } else if state.configuration.verifyPeer {
                // verifyPeer is true but we have no key to verify with
                throw TLSHandshakeError.certificateVerificationFailed("No public key available for verification")
            }
            // If verifyPeer is false, skip signature verification

            // Update transcript
            let message = HandshakeCodec.encode(type: .certificateVerify, content: data)
            state.context.transcriptHash.update(with: message)

            // Call custom certificate validator if configured
            // Custom validation hook (e.g., application-specific peer identity extraction)
            if let validator = state.configuration.certificateValidator,
               let peerCerts = state.context.peerCertificates {
                let peerInfo = try validator(peerCerts)
                state.context.validatedPeerInfo = peerInfo
            }

            // Transition state
            state.handshakeState = .waitFinished

            return []
        }
    }

    // MARK: - Process Finished

    /// Process a server Finished message
    /// - Parameter data: The Finished message content
    /// - Returns: TLS outputs including application keys and client Finished
    package func processServerFinished(_ data: Data) throws -> (outputs: [TLSOutput], clientFinished: Data) {
        return try state.withLock { state in
            // SECURITY: Only accept Finished in .waitFinished state.
            //
            // For non-PSK handshakes, the server MUST send Certificate and
            // CertificateVerify before Finished (RFC 8446 Section 4.4).
            // processEncryptedExtensions() transitions to .waitCertificateOrCertificateRequest
            // for non-PSK flows, and processCertificateVerify() transitions to .waitFinished
            // after validating the server's signature.
            //
            // For PSK handshakes, processEncryptedExtensions() transitions directly
            // to .waitFinished (skipping Certificate/CertificateVerify as per RFC 8446
            // Section 2.3), so this check is correct for both flows.
            //
            // Accepting Finished in .waitCertificate or .waitCertificateVerify would
            // allow a malicious server to bypass certificate validation entirely.
            guard state.handshakeState == .waitFinished else {
                throw TLSHandshakeError.unexpectedMessage(
                    "Unexpected Finished in state \(state.handshakeState); " +
                    "server must complete Certificate/CertificateVerify sequence first"
                )
            }

            let serverFinished = try Finished.decode(from: data)

            // Verify server Finished
            guard let serverHandshakeSecret = state.context.serverHandshakeSecret else {
                throw TLSHandshakeError.internalError("Missing server handshake secret")
            }

            let serverFinishedKey = state.context.keySchedule.finishedKey(from: serverHandshakeSecret)
            let transcriptHash = state.context.transcriptHash.currentHash()
            let expectedVerifyData = state.context.keySchedule.finishedVerifyData(
                forKey: serverFinishedKey,
                transcriptHash: transcriptHash
            )

            guard serverFinished.verify(expected: expectedVerifyData) else {
                throw TLSHandshakeError.finishedVerificationFailed
            }

            // Update transcript with server Finished
            let serverFinishedMessage = HandshakeCodec.encode(type: .finished, content: data)
            state.context.transcriptHash.update(with: serverFinishedMessage)

            // Derive application secrets
            let appTranscriptHash = state.context.transcriptHash.currentHash()
            let (clientAppSecret, serverAppSecret) = try state.context.keySchedule.deriveApplicationSecrets(
                transcriptHash: appTranscriptHash
            )

            state.context.clientApplicationSecret = clientAppSecret
            state.context.serverApplicationSecret = serverAppSecret

            // Derive exporter master secret
            let exporterMasterSecret = try state.context.keySchedule.deriveExporterMasterSecret(
                transcriptHash: appTranscriptHash
            )
            state.context.exporterMasterSecret = exporterMasterSecret

            // === Client Certificate and CertificateVerify (for mutual TLS) ===
            // RFC 8446 Section 4.4: If server sent CertificateRequest, client responds
            // with Certificate and CertificateVerify BEFORE Finished.
            var clientCertMessages: [Data] = []

            if state.context.clientCertificateRequested {
                // Check if client has certificate material configured
                if let signingKey = state.configuration.signingKey,
                   let certChain = state.configuration.certificateChain,
                   !certChain.isEmpty {

                    // Send Certificate (with echoed context from CertificateRequest)
                    let certificate = Certificate(
                        certificateRequestContext: state.context.certificateRequestContext,
                        certificates: certChain
                    )
                    let certMessage = certificate.encodeAsHandshake()
                    state.context.transcriptHash.update(with: certMessage)
                    clientCertMessages.append(certMessage)

                    // Send CertificateVerify
                    // Sign transcript up to (not including) CertificateVerify
                    let transcriptForCV = state.context.transcriptHash.currentHash()
                    let signatureContent = TLSSignature.certificateVerifyContent(
                        transcriptHash: transcriptForCV,
                        isServer: false  // This is CLIENT's CertificateVerify
                    )

                    let signature = try signingKey.sign(signatureContent)
                    let certificateVerify = CertificateVerify(
                        algorithm: signingKey.scheme,
                        signature: signature
                    )
                    let cvMessage = certificateVerify.encodeAsHandshake()
                    state.context.transcriptHash.update(with: cvMessage)
                    clientCertMessages.append(cvMessage)
                } else {
                    // Client has no certificate material - send empty Certificate
                    // RFC 8446 Section 4.4.2: If client has no certificates, send empty list
                    let emptyCertificate = Certificate(
                        certificateRequestContext: state.context.certificateRequestContext,
                        certificates: []
                    )
                    let certMessage = emptyCertificate.encodeAsHandshake()
                    state.context.transcriptHash.update(with: certMessage)
                    clientCertMessages.append(certMessage)
                    // No CertificateVerify for empty certificate
                }
            }

            // Generate client Finished
            guard let clientHandshakeSecret = state.context.clientHandshakeSecret else {
                throw TLSHandshakeError.internalError("Missing client handshake secret")
            }

            let clientFinishedKey = state.context.keySchedule.finishedKey(from: clientHandshakeSecret)
            let clientFinishedTranscript = state.context.transcriptHash.currentHash()
            let clientVerifyData = state.context.keySchedule.finishedVerifyData(
                forKey: clientFinishedKey,
                transcriptHash: clientFinishedTranscript
            )

            let clientFinished = Finished(verifyData: clientVerifyData)
            let clientFinishedMessage = clientFinished.encodeAsHandshake()

            // Combine all client messages: [Certificate, CertificateVerify], Finished
            let allClientMessages = clientCertMessages + [clientFinishedMessage]
            let combinedClientMessage = allClientMessages.reduce(Data()) { $0 + $1 }

            // Update transcript with client Finished
            state.context.transcriptHash.update(with: clientFinishedMessage)

            // Derive resumption master secret (for session tickets)
            let resumptionTranscriptHash = state.context.transcriptHash.currentHash()
            let resumptionMasterSecret = try state.context.keySchedule.deriveResumptionMasterSecret(
                transcriptHash: resumptionTranscriptHash
            )
            state.context.resumptionMasterSecret = resumptionMasterSecret

            // Transition state
            state.handshakeState = .connected

            var outputs: [TLSOutput] = []

            // Application keys
            outputs.append(.keysAvailable(KeysAvailableInfo(
                level: .application,
                clientSecret: clientAppSecret,
                serverSecret: serverAppSecret
            )))

            // Handshake complete
            outputs.append(.handshakeComplete(HandshakeCompleteInfo(
                alpn: state.context.negotiatedALPN,
                zeroRTTAccepted: state.context.earlyDataState.earlyDataAccepted,
                resumptionTicket: nil
            )))

            // Return combined message (Certificate + CertificateVerify + Finished for mTLS,
            // or just Finished for non-mTLS)
            return (outputs, combinedClientMessage)
        }
    }

    // MARK: - Process NewSessionTicket

    /// Process a NewSessionTicket message (received post-handshake)
    /// - Parameter data: The NewSessionTicket message content
    /// - Returns: The derived session ticket data for future use
    package func processNewSessionTicket(_ data: Data) throws -> SessionTicketData {
        return try state.withLock { state in
            guard state.handshakeState == .connected else {
                throw TLSHandshakeError.unexpectedMessage("NewSessionTicket received before handshake complete")
            }

            let ticket = try NewSessionTicket.decode(from: data)

            // Get resumption master secret
            guard let resumptionMasterSecret = state.context.resumptionMasterSecret,
                  let cipherSuite = state.context.cipherSuite else {
                throw TLSHandshakeError.internalError("Missing resumption master secret or cipher suite")
            }

            // Derive PSK from resumption master secret and ticket nonce
            let resumptionPSK = state.context.keySchedule.deriveResumptionPSK(
                resumptionMasterSecret: resumptionMasterSecret,
                ticketNonce: ticket.ticketNonce
            )

            // Extract max early data size from extensions
            var maxEarlyDataSize: UInt32 = 0
            for ext in ticket.extensions {
                if case .earlyData(let earlyData) = ext {
                    if case .newSessionTicket(let size) = earlyData {
                        maxEarlyDataSize = size
                    }
                }
            }

            // Create session ticket data
            let ticketData = SessionTicketData(
                ticket: ticket.ticket,
                resumptionPSK: resumptionPSK.withUnsafeBytes { Data($0) },
                maxEarlyDataSize: maxEarlyDataSize,
                ticketAgeAdd: ticket.ticketAgeAdd,
                receiveTime: Date(),
                lifetime: ticket.ticketLifetime,
                cipherSuite: cipherSuite,
                serverName: state.configuration.serverName,
                alpn: state.context.negotiatedALPN
            )

            return ticketData
        }
    }

    // MARK: - Accessors

    /// Current handshake state
    package var handshakeState: ClientHandshakeState {
        state.withLock { $0.handshakeState }
    }

    /// Whether the handshake is complete
    package var isConnected: Bool {
        state.withLock { $0.handshakeState == .connected }
    }

    /// Negotiated ALPN protocol
    package var negotiatedALPN: String? {
        state.withLock { $0.context.negotiatedALPN }
    }

    /// Peer transport parameters
    package var peerTransportParameters: Data? {
        state.withLock { $0.context.peerTransportParameters }
    }

    /// Exporter master secret (available after handshake completion)
    package var exporterMasterSecret: SymmetricKey? {
        state.withLock { $0.context.exporterMasterSecret }
    }

    /// Whether PSK was used in this handshake
    package var pskUsed: Bool {
        state.withLock { $0.context.pskUsed }
    }

    /// Whether early data (0-RTT) was accepted by the server
    package var earlyDataAccepted: Bool {
        state.withLock { $0.context.earlyDataState.earlyDataAccepted }
    }

    /// Resumption master secret (for deriving new session tickets)
    package var resumptionMasterSecret: SymmetricKey? {
        state.withLock { $0.context.resumptionMasterSecret }
    }

    /// Peer certificates (raw DER data, leaf certificate first)
    package var peerCertificates: [Data]? {
        state.withLock { $0.context.peerCertificates }
    }

    /// Parsed peer leaf certificate
    package var peerCertificate: X509Certificate? {
        state.withLock { $0.context.peerCertificate }
    }

    /// Validated peer info from certificate validator callback.
    ///
    /// This contains the value returned by `TLSConfiguration.certificateValidator`
    /// after successful certificate validation (e.g., application-specific peer identity).
    package var validatedPeerInfo: (any Sendable)? {
        state.withLock { $0.context.validatedPeerInfo }
    }

    /// The validated certificate chain from the most recent certificate processing.
    ///
    /// Available after `processCertificate()` succeeds with `verifyPeer == true`.
    /// Used by `TLS13Handler` to perform async revocation checks.
    public var validatedChain: ValidatedChain? {
        state.withLock { $0.context.validatedChain }
    }

    /// Takes (removes and returns) the validated chain from context.
    ///
    /// This ensures the revocation check is performed exactly once per
    /// certificate processing â€” the chain is consumed on first access.
    public func takeValidatedChain() -> ValidatedChain? {
        state.withLock { state in
            let chain = state.context.validatedChain
            state.context.validatedChain = nil
            return chain
        }
    }
}
